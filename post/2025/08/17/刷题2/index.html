<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>刷题（2） | 0号树洞</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/>主页</a></li><li><a href=/about/>关于</a></li><li><a href=/categories/>分类</a></li><li><a href=/tags/>标签</a></li><li><a href=/index.xml>Subscribe</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>刷题（2）</span></h1><h2 class=date>2025/08/17</h2></div><main><p>马上要笔试了赶紧学习一下</p><h3 id=1-电迁移和电迁移违例electro-migration-violation>1. 电迁移和电迁移违例(Electro-Migration Violation)</h3><p>电迁移：电流流动引起的原子运动</p><p>电迁移故障用平均故障时间来描述</p>$$
MTTF\propto J^{-N}e^{\frac{E_a}{kT}}
$$<p>受到 <strong>J</strong>电流密度、<strong>N</strong>比例因子、<strong>T</strong>温度、<strong>Ea</strong>激活能影响</p><p>产生的原因：</p><ol><li>金属线太长，增加电阻，温度上升</li><li>fanout太多，大电流</li><li>cell驱动太强比如X16,X20，导致电流密度大</li><li>transition time 太快</li></ol><p>改善措施包括：</p><ol><li>增加互联宽度，降低电流密度</li><li>使用具有高电迁移耐力的材料，金和铜</li><li>使用冗余通孔分流电流强度</li><li>减少互连器件之间的间距（减少互连长度）</li><li>设计低电压水平的电流</li></ol><h3 id=2-运行以下程序输出的值是>2. 运行以下程序输出的值是？</h3><pre><code class=language-systemverilog>int addr = 32'ha;
bit is_legal;
bit [33:0] info0;

initial begin
    if (addr[0])
        is_legal = 0;
    else
        is_legal = 1;
    info0 = ~is_legal;
    info0 = {info0, addr};
    info0 = {info0, 0};
    $display(&quot;0x%0h&quot;, info0);
end
endmodule
</code></pre><p>这里的关键点首先是is_legal = 1 ; is_legal = ~is_legal;</p><p><code>~</code>是按位操作，所以这里运行完is_legal是34’b3_ffff_fffe</p><blockquote><p>~ 按位取反</p><p>! 逻辑非</p></blockquote><p>其次是<code>{info0,0}</code>这里0没有指定位宽默认为32位。这里拼接之后就是34+32 = 66 bits赋值的时候截取低32bit。</p><h3 id=3-axi带宽分析>3. AXI带宽分析</h3><p>几个关键参数：</p><p><strong>绝对延时</strong>：M发出命令到M收到响应的延时；<strong>平均延迟</strong>：总传输延迟除以传输次数</p><pre><code class=language-text>发出请求-&gt;传输数据(1-2-3-4-5-6-7-8)-&gt;收到响应
|----------------绝对延迟---------------&gt;|
</code></pre><p>不同的传输过程的绝对延迟不一样。</p><p>当outstanding为3的时候，并且突发长度为8。</p><pre><code class=language-text>请求1 请求2 请求3
	 数据1(1-2-3-4-5-6-7-8)数据2(1-2-3-4-5-6-7-8)数据3(1-2-3-4-5-6-7-8)
	 					  响应1                 响应2                 响应3
|--------绝对延迟1------------&gt;|
      |-----------------绝对延迟2------------------&gt;|
      	   |--------------------------绝对延迟3--------------------------&gt;|
|---------平均延迟1-------&gt;|--------平均延迟2-------&gt;|------平均延迟3-------&gt;|
</code></pre><p>outstanding并没有减少单次传输<code>绝对延迟</code>（甚至更长），但是减少了多次传输的<code>平均延迟</code></p><p>换句话说，由于三次传输的总时间减少，可以减少系统总线的占用，提高总线的带宽。</p><p>以上都是以写过程作为示例，下面则是通过一个读过程计算带宽。</p><p>假设系统的总线带宽：128bit=16Byte，总线时钟频率800MHz，最大突发长度16，outstanding为8，平均读延迟800ns。计算系统的平均带宽？</p><blockquote><p><a href=https://zhuanlan.zhihu.com/p/720178667>参考</a>中后面的平均延迟时间应该指的是单次传输的<strong>必要时间</strong>，前面的平均时间是用来比较osd对传输速率的影响。这里我更倾向于8次osd的总延迟为800ns，也就是下面所示的过程。</p></blockquote><pre><code class=language-tex>请求1 请求2 ... 请求7 请求8
	              数据1（1-2...15-16）...数据8
|------------------800ns------------------&gt;|
</code></pre><p>所以平均带宽应该为 最大带宽×有效数据传输的占比 即12.8GBps×1.25ns×16×8/800ns = 2.56GBps</p></main><footer><link rel=stylesheet href=//cdn.jsdelivr.net/npm/katex/dist/katex.min.css><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/math-code.min.js defer></script><script src=//cdn.jsdelivr.net/npm/katex/dist/katex.min.js defer></script><script src=//cdn.jsdelivr.net/npm/katex/dist/contrib/auto-render.min.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/render-katex.js defer></script><script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.min.js defer></script><hr>© <a href=https://zhaolinghao00.github.io>linghao</a> 2025 &ndash; 2025 | <a href=https://github.com/zhaolinghao00>Github</a></footer></body></html>